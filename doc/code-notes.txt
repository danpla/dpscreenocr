* A source file should include headers in the following order:

  * If the file is C/CPP (foo.cpp), the corresponding header of this
    file (foo.h)
  * Standard C/C++ library headers. On Unix-like systems, OS API
    (POSIX) headers may also be in this group.
  * OS API headers.
  * Other third-party headers, including src/thirdparty.
  * Our headers from src/.

  These #include groups should be separated by an empty line.

* When a CPP file implements a function from a C header, the signature
  should be copied verbatim to the CPP file. This includes the case
  when a C type from the signature is available in CPP in the std::
  namespace, e.g. size_t (<stddef.h>) vs std::size_t (<cstddef>).

* In both C and C++ code, a pointer is not expected to be null (unless
  the opposite is explicitly stated in the documentation) in case it
  implies an arbitrary sized memory region (e.g. array, C string,
  void*, etc.) rather than a pointer to a single object. Other pointer
  types are handled as follows:

  * C: A function from a public C API should expect a pointer argument
    to be null. If null is an invalid value, the routine should either
    report an error or (if there's no way to report an error) do
    nothing.

  * C++: In C++ code, raw pointers are only used to express optional
    references and thus always expected to be null. Exceptions to
    this rule should be revised to use references (or
    reference_wrapper), or at least be explicitly documented.

    In case of errors, a function returning a created an object via a
    smart pointer should either throw an exception and never return
    null (this is the preferred way), or never throw and return null
    to signal an error.

* Don't use UTF-8 string literals (u8""). Since C++20, their type is
  changed from char to char8_t, breaking the backward compatibility.

  To insert UTF-8 bytes in a string, use 3 digit octal escape
  sequences. Don't use hex sequences, as they consume as much valid
  hex characters as possible. The only exception is when they are
  separated from the rest of the string by literal concatenation:

      "\xC2\xA9" "2018" (gives Â©2018)

* In genral, arrays should be defined without an explicit size. When
  the number of elements in the array must match some constant, it
  should be enforced with a static_assert() following the array
  definition.

  The reason is that specifying an array size (both for plain and
  std::array) when using aggregate initialization is broken by design:
  it allows you to provide fewer values than specified by the array
  type, and compilers don't even warn about this. This is especially
  dangerous when the size comes from a constant that one day may
  become N times larger.

* Use underscores instead of hyphens in CMake target names.

* All global configuration macros and CMake options have DPSO_ prefix.
  A CMakeLists file should explicitly set the macro value in
  target_compile_definitions() rather than leaving it undefined; an
  undefined macro may be set to a default value in the source code,
  and that default may not match the CMake option.

* ENABLE_NLS=1 macro should be defined to enable gettext. If you use
  dpso_utils/intl.h, this can be done with DPSO_ENABLE_NLS CMake
  option (enabled by default). If you use your own gettext.h, set
  ENABLE_NLS manually.
