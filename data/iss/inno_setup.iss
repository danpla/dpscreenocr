
#include "inno_setup_config.isi"

[Setup]
#if APP_IS_64_BIT
ArchitecturesInstallIn64BitMode=x64
ArchitecturesAllowed=x64
#endif

AppName={#APP_NAME}
AppVersion={#APP_VERSION}
AppPublisher={#APP_AUTHOR}
AppPublisherURL={#APP_URL}
AppSupportURL={#APP_URL}
LicenseFile={#APP_SOURCE_DIR}\LICENSE.txt

PrivilegesRequiredOverridesAllowed=dialog
; We know that we should not make user-specific changes in admin
; install mode. Our entry in [Files] that uses {localappdata} has
; "Check:" that will skip it in admin mode, so disable the warning.
UsedUserAreasWarning=no

OutputDir=.

#if APP_IS_64_BIT
#define OUTPUT_SUFFIX 64
#else
#define OUTPUT_SUFFIX 32
#endif

OutputBaseFilename={#APP_FILE_NAME}-{#APP_VERSION}-win{#OUTPUT_SUFFIX}

DefaultDirName={autopf}\{#APP_NAME}
DefaultGroupName={#APP_NAME}
UninstallDisplayIcon={app}\{#APP_FILE_NAME}.exe
SetupIconFile={#APP_SOURCE_DIR}\data\icons\{#APP_FILE_NAME}.ico

ShowLanguageDialog=auto
WizardImageFile={#APP_SOURCE_DIR}\data\iss\wizard.bmp
WizardSmallImageFile={#APP_SOURCE_DIR}\data\iss\wizard_small.bmp

Compression=lzma2
SolidCompression=yes

[Files]
Source: "{#APP_FILE_NAME}.exe"; \
  DestDir: "{app}"; \
  Flags: ignoreversion
Source: "*.dll"; \
  DestDir: "{app}"; \
  Flags: ignoreversion
Source: "doc\*"; \
  DestDir: "{app}\doc"; \
  Flags: ignoreversion recursesubdirs
Source: "icons\*"; \
  DestDir: "{app}\icons"; \
  Flags: ignoreversion recursesubdirs
#if APP_USES_NLS
Source: "locale\*"; \
  DestDir: "{app}\locale"; \
  Flags: ignoreversion recursesubdirs
#endif

#define TESSDATA_DIR "tessdata"
#define TESSERACT_DATA_DIR "tesseract_data"
#define ENG_TRAINEDDATA "eng.traineddata"

; Here we try to migrate any custom user data from the previously
; installed version created by "CPack -G NSIS". At this moment, the
; old version is already removed together with the eng data, so
; NsisGetTessdataDir will only exist if it actually has custom data.
; Note that there's no "uninsneveruninstall" flag, and we don't remove
; files from NsisGetTessdataDir. See comments in the code section for
; the details.
Source: "{code:NsisGetTessdataDir}\*"; \
  DestDir: "{app}\{#TESSERACT_DATA_DIR}"; \
  Check: DirExists(ExpandConstant('{code:NsisGetTessdataDir}')); \
  Flags: ignoreversion recursesubdirs external

; Our application copies TESSERACT_DATA_DIR (if any) to the current
; user's local app data directory on first start; this is the only
; purpose of TESSERACT_DATA_DIR in the installation directory.
; However, when we install for the current user, we can do the same
; copying from the installer and avoid installing TESSERACT_DATA_DIR
; to save disk space. Therefore, there are two source lines below: for
; admin and non-admin install modes, respectively.
; onlyifdestfileexists skipifsourcedoesntexist
Source: "{#TESSERACT_DATA_DIR}\{#ENG_TRAINEDDATA}"; \
  DestDir: "{app}\{#TESSERACT_DATA_DIR}"; \
  Check: ShouldInstallEngTraineddata(); \
  Flags: ignoreversion
Source: "{#TESSERACT_DATA_DIR}\{#ENG_TRAINEDDATA}"; \
  DestDir: "{localappdata}\{#APP_FILE_NAME}\{#TESSERACT_DATA_DIR}"; \
  Check: ShouldCopyEngTraineddataForCurrentUser(); \
  Flags: ignoreversion uninsneveruninstall

#if APP_UI == "qt"
Source: "platforms\*"; \
  DestDir: "{app}\platforms"; \
  Flags: ignoreversion recursesubdirs
Source: "styles\*"; \
  DestDir: "{app}\styles"; \
  Flags: ignoreversion recursesubdirs
#if APP_USES_NLS
Source: "translations\*"; \
  DestDir: "{app}\translations"; \
  Flags: ignoreversion recursesubdirs
#endif
#endif

[Icons]
Name: "{group}\{#APP_NAME}"; \
  Filename: "{app}\{#APP_FILE_NAME}.exe"
Name: "{group}\{cm:UninstallProgram,{#APP_NAME}}"; \
  Filename: "{uninstallexe}"
Name: "{group}\Documents"; \
  Filename: "{app}\doc"

[Languages]
Name: "en"; MessagesFile: "compiler:Default.isl"
#if APP_USES_NLS
#include "inno_setup_languages.isi"
#endif

[Code]

procedure OurLog(const Scope, Msg: String);
begin
  Log('[{#APP_FILE_NAME}] ' + Scope + ': ' + Msg);
end;

// In previous app versions that use the installer generated by
// "cpack -G NSIS", users have to put custom Tesseract data in the
// "tessdata" directory located in the installation path.
//
// Since version 1.1.0 (which uses Inno Setup), "tessdata" was renamed
// to "tesseract_data". Instead of using data directly from
// "tesseract_data", the application now just copies this directory to
// the user's local app data path on the first start.
//
// When updating from an old NSIS-based version, we need to migrate
// all custom user data from "tessdata" of the old installation to
// "tesseract_data" of the new one. Although it's possible to just
// copy the data before uninstalling the old version, we instead take
// a different approach based on a [Files] entry with an "external"
// flag. The main advantage is that the uninstaller will remove copied
// data from "tesseract_data". This is more robust than using
// [UninstallDelete], which will wipe not only files that were copied
// from "tessdata", but also those that were in "tesseract_data"
// before installation. We also don't have to write a routine to copy
// a directory (Inno Setup does not provide one as of version 6.2).
//
// Note that we don't remove files in the "tessdata" directory after
// copying them. We can't be sure the user no longer needs them.
//
// The [Files] entry is processed after the old version is removed, so
// we have to cache some information before invoking the uninstaller.
// First is NsisInstallDirPath that is used in "Source:". Second is
// NsisWasEngTraineddata, which tells whether the eng data existed;
// if not, this means it was intentionally removed by the user and we
// don't need to install it again.
//
// Keep in mind that our old NSIS-based installer only works in admin
// mode, i.e. it only installs for all users. If we are in non-admin
// mode, we don't touch anything NSIS-related at all.
var
  // Empty if the old NSIS-based version is not installed, or if we
  // are in the non-admin install mode.
  NsisInstallDirPath: String;
  // Only relevant if NsisInstallDirPath is not empty.
  NsisWasEngTraineddata: Boolean;

// For {code:...}
function NsisGetTessdataDir(Param: String): String;
begin
  Result := NsisInstallDirPath + '\{#TESSDATA_DIR}';
end;

// The two following Should*() checks are used in "Check:"; they are
// mutually exclusive and intended for admin and non-admin install
// modes, respectively. See the [Files] section for the details.

function ShouldInstallEngTraineddata(): Boolean;
begin
  Result := IsAdminInstallMode()
    and ((NsisInstallDirPath = '') or NsisWasEngTraineddata);
end;

function ShouldCopyEngTraineddataForCurrentUser(): Boolean;
begin
  Result := not IsAdminInstallMode()
    // To handle the case when the user updates from an old version
    // that doesn't use data from {localappdata}, we must check the
    // existence of TESSERACT_DATA_DIR rather that just the app data
    // directory.
    and not DirExists(
      ExpandConstant('{localappdata}')
      + '\{#APP_FILE_NAME}\{#TESSERACT_DATA_DIR}');
end;

function LocateRootRegKey(
  const RootKey32, RootKey64: Integer;
  const SubKeyName: String;
  var RootKey: Integer): Boolean;
begin
  Result := True;

  if RegKeyExists(RootKey32, SubKeyName) then
    RootKey := RootKey32
  else if IsWin64 and RegKeyExists(RootKey64, SubKeyName) then
    RootKey := RootKey64
  else
    Result := False;
end;

const
  UninstallStringKey = 'UninstallString';

// Return path to uninstaller created by our old installer made by
// "CPack -G NSIS", or an empty string if it's not installed.
function NsisGetUninstallerPath(): String;
var
  LogScope: String;
  RootRegKey: Integer;
  UninstallRegPath: String;
  UninstallString: String;
  UninstallerPath: String;
  CPackInstallDir: String;
  UninstallerDir: String;
begin
  LogScope := 'NsisGetUninstallerPath';

  Result := '';

  // Our old NSIS-based installer only works in admin mode, i.e. it
  // installs for all users.
  if not IsAdminInstallMode() then
    exit;

  UninstallRegPath :=
    'Software\Microsoft\Windows\CurrentVersion\Uninstall\{#APP_NAME}';

  if not LocateRootRegKey(
      HKLM32, HKLM64, UninstallRegPath, RootRegKey) then
    exit;

  if not RegQueryStringValue(
      RootRegKey, UninstallRegPath,
      UninstallStringKey, UninstallString) then
    exit;

  // Our old installer was actually built with an older CPack version
  // that doesn't add quotes around UninstallString.
  UninstallerPath := RemoveQuotes(UninstallString);
  if not FileExists(UninstallerPath) then
  begin
    OurLog(LogScope, format(
      '"%s" doesn''t point to a file or the file ' +
      'doesn''t exist', [UninstallerPath]));
    exit;
  end;

  // Old "CPack -G NSIS" doesn't write InstallLocation to the
  // Uninstall section. Instead, it writes the path to
  // "Software\(App author)\(App name)". Use this to check if this
  // is actually our old installer. Otherwise, there is no guarantee
  // that this is really an NSIS uninstaller, and we should not try to
  // execute it with NSIS-specific arguments.
  if not RegQueryStringValue(
    RootRegKey, 'Software\{#APP_AUTHOR}\{#APP_NAME}',
    '', CPackInstallDir) then
  begin
    OurLog(LogScope, 'No "Software\{#APP_AUTHOR}\{#APP_NAME}"');
    exit;
  end;

  UninstallerDir := ExtractFileDir(UninstallerPath);
  if CPackInstallDir <> UninstallerDir then
  begin
    OurLog(LogScope, format(
      'String from "Software\{#APP_AUTHOR}\{#APP_NAME}" (%s) is ' +
      'not the same as path to uninstaller directory (%s)'
      , [CPackInstallDir, UninstallerDir]));
    exit;
  end;

  Result := UninstallerPath;
end;

// Remove an installation created by our old installer made by
// "CPack -G NSIS".
procedure NsisUninstallExisting(const UninstallerPath: String);
var
  LogScope: String;
  UninstallerDir: String;
  ExecResultCode: Integer;
begin
  LogScope := 'NsisUninstallExisting';

  if UninstallerPath = '' then
    exit;

  UninstallerDir := ExtractFileDir(UninstallerPath);

  if not Exec(
    UninstallerPath, '/S _?=' + UninstallerDir, '',
    SW_HIDE, ewWaitUntilTerminated, ExecResultCode) then
  begin
    OurLog(LogScope, format(
      'Can''t execute "%s /S _?=%s": %s (code %d)'
      , [UninstallerPath, UninstallerDir,
      SysErrorMessage(ExecResultCode), ExecResultCode]));
    exit;
  end;

  if not DeleteFile(UninstallerPath) then
  begin
    OurLog(LogScope, format(
      'Can''t delete \"%s\"', [UninstallerPath]));
    exit;
  end;

  if not RemoveDir(UninstallerDir) then
    OurLog(LogScope, format(
      'Can''t delete "%s"; the directory is probably not ' +
      'empty', [UninstallerDir]));

  OurLog(LogScope, format(
    'Uninstalled existing via "%s"', [UninstallerPath]));
end;

const
  UninstallerMutexName = 'iss_{#APP_FILE_NAME}_uninstaller_mutex';

// Returns false if mutex was not released within the given time.
function WaitForMutex(
  const MutexName: String;
  const MaxWaitTimeMilliseconds: Integer): Boolean;
var
  CheckInterval: Integer;
  RemainingWaitTime: Integer;
begin
  CheckInterval := 200;
  RemainingWaitTime := MaxWaitTimeMilliseconds;

  while True do
  begin
    if not CheckForMutexes(MutexName) then
    begin
      Result := True;
      exit;
    end;

    if RemainingWaitTime <= 0 then
      break;

    if CheckInterval > RemainingWaitTime then
      CheckInterval := RemainingWaitTime;

    Sleep(CheckInterval);

    RemainingWaitTime := RemainingWaitTime - CheckInterval;
  end;

  Result := False;
end;

// Removing the previous version is not actually necessary with Inno
// Setup: it always appends to the uninstall log, so the uninstaller
// will never leave any files, even if the user has installed several
// versions of the app with different file hierarchies. However, this
// also means that until the user uninstalls the app, unnecessary
// files from previous versions will still waste disk space, so let's
// try to uninstall the existing version automatically.
//
// Alternatively, we could use the [InstallDelete] section, but it's
// rather cumbersome to keep a list of files to be removed for all
// previous versions, and there will be no full cleanup if the user
// rolls back to a previous version.
procedure UninstallExisting();
var
  LogScope: String;
  RootRegKey: Integer;
  UninstallRegPath: String;
  UninstallString: String;
  ExecResultCode: Integer;
begin
  LogScope := 'UninstallExisting';
  UninstallRegPath :=
    'Software\Microsoft\Windows\CurrentVersion\Uninstall\' +
    '{#APP_NAME}_is1';

  if not LocateRootRegKey(
      HKA32, HKA64, UninstallRegPath, RootRegKey) then
    exit;

  if not RegQueryStringValue(
      RootRegKey, UninstallRegPath,
      UninstallStringKey, UninstallString) then
    exit;

  if not Exec(
    '>',
    UninstallString + ' /VERYSILENT /SUPPRESSMSGBOXES /NORESTART',
    '',
    SW_HIDE, ewWaitUntilTerminated, ExecResultCode) then
  begin
    OurLog(LogScope, format(
      'Can''t execute "%s": %s (code %d)'
      , [UninstallString,
      SysErrorMessage(ExecResultCode), ExecResultCode]));
    exit;
  end;

  if not WaitForMutex(UninstallerMutexName, 10000) then
    OurLog(LogScope, 'Uninstaller didn''t release the mutex');

  OurLog(LogScope, format(
    'Uninstalled existing via "%s"', [UninstallString]));
end;

function InitializeSetup(): Boolean;
begin
  NsisInstallDirPath := '';
  NsisWasEngTraineddata := False;

  Result := True;
end;

procedure CurStepChanged(CurStep: TSetupStep);
var
  NsisUninstallerPath: String;
begin
  if CurStep = ssInstall then
  begin
    NsisUninstallerPath := NsisGetUninstallerPath();
    NsisInstallDirPath := ExtractFileDir(NsisUninstallerPath);
    NsisWasEngTraineddata :=
      (NsisInstallDirPath <> '')
      and FileExists(
        NsisInstallDirPath + '\{#TESSDATA_DIR}\{#ENG_TRAINEDDATA}');

    NsisUninstallExisting(NsisUninstallerPath);
    UninstallExisting();
  end;
end;

function InitializeUninstall(): Boolean;
begin
  CreateMutex(UninstallerMutexName);
  Result := True;
end;
