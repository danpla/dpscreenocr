
#cmakedefine01 APP_IS_64_BIT
#cmakedefine01 DPSO_ENABLE_NLS

[Setup]
#if APP_IS_64_BIT
ArchitecturesInstallIn64BitMode=x64
ArchitecturesAllowed=x64
#endif

AppName=@APP_NAME@
AppVersion=@APP_VERSION@
AppPublisher=@APP_AUTHOR@
AppPublisherURL=@APP_URL@
AppSupportURL=@APP_URL@
LicenseFile=@APP_SOURCE_DIR@\LICENSE.txt

PrivilegesRequiredOverridesAllowed=dialog

OutputDir=.

#if APP_IS_64_BIT
#define OUTPUT_SUFFIX 64
#else
#define OUTPUT_SUFFIX 32
#endif

OutputBaseFilename=@APP_FILE_NAME@-@APP_VERSION@-win{#OUTPUT_SUFFIX}

DefaultDirName={autopf}\@APP_NAME@
DefaultGroupName=@APP_NAME@
UninstallDisplayIcon={app}\@APP_FILE_NAME@.exe
SetupIconFile=@APP_SOURCE_DIR@\data\icons\@APP_FILE_NAME@.ico

ShowLanguageDialog=auto
WizardImageFile=@APP_SOURCE_DIR@\data\iss\wizard.bmp
WizardSmallImageFile=@APP_SOURCE_DIR@\data\iss\wizard_small.bmp

Compression=lzma2
SolidCompression=yes

[Files]
Source: "@APP_FILE_NAME@.exe"; DestDir: "{app}"; Flags: ignoreversion
Source: "*.dll"; DestDir: "{app}"; Flags: ignoreversion
Source: "doc\*"; DestDir: "{app}\doc"; Flags: ignoreversion recursesubdirs
Source: "icons\*"; DestDir: "{app}\icons"; Flags: ignoreversion recursesubdirs
; If the tessdata directory already exists, chances are that the user
; removed eng as unnecessary, so don't install it again.
Source: "tessdata\eng.traineddata"; DestDir: "{app}\tessdata"; Check: not DirExists(ExpandConstant('{app}\tessdata')); Flags: ignoreversion
#if DPSO_ENABLE_NLS
Source: "locale\*"; DestDir: "{app}\locale"; Flags: ignoreversion recursesubdirs
#endif

#if "@DPSO_UI@" == "qt"
Source: "platforms\*"; DestDir: "{app}\platforms"; Flags: ignoreversion recursesubdirs
Source: "styles\*"; DestDir: "{app}\styles"; Flags: ignoreversion recursesubdirs
#if DPSO_ENABLE_NLS
Source: "translations\*"; DestDir: "{app}\translations"; Flags: ignoreversion recursesubdirs
#endif
#endif

[Icons]
Name: "{group}\@APP_NAME@"; Filename: "{app}\@APP_FILE_NAME@.exe"
Name: "{group}\{cm:UninstallProgram,@APP_NAME@}"; Filename: "{uninstallexe}"
Name: "{group}\Documents"; Filename: "{app}\doc"

[Languages]
Name: "en"; MessagesFile: "compiler:Default.isl"
#if DPSO_ENABLE_NLS
#include "inno_setup_languages.isi"
#endif

[Code]

procedure OurLog(const scope, msg: String);
begin
  Log('[@APP_FILE_NAME@] ' + scope + ': ' + msg);
end;

function LocateRootRegKey(
  const RootKey32, RootKey64: Integer;
  const SubKeyName: String;
  var RootKey: Integer): Boolean;
begin
  Result := True;

  if RegKeyExists(RootKey32, SubKeyName) then
    RootKey := RootKey32
  else if IsWin64 and RegKeyExists(RootKey64, SubKeyName) then
    RootKey := RootKey64
  else
    Result := False;
end;

const
  UninstallStringKey = 'UninstallString';

// Try to remove an installation created by our old installer made by
// "CPack -G NSIS".
procedure UninstallExistingNsis();
var
  LogScope: String;
  RootRegKey: Integer;
  UninstallRegPath: String;
  UninstallString: String;
  UninstallerPath: String;
  CPackUninstallerDir: String;
  UninstallerDir: String;
  ExecResultCode: Integer;
begin
  if not IsAdminInstallMode() then
    exit;

  LogScope := 'UninstallExistingNsis';
  UninstallRegPath :=
    'Software\Microsoft\Windows\CurrentVersion\Uninstall\@APP_NAME@';

  if not LocateRootRegKey(
      HKLM32, HKLM64, UninstallRegPath, RootRegKey) then
    exit;

  if not RegQueryStringValue(
      RootRegKey, UninstallRegPath,
      UninstallStringKey, UninstallString) then
    exit;

  // Our old installer was actually built with an older CPack version
  // that doesn't add quotes around UninstallString.
  UninstallerPath := RemoveQuotes(UninstallString);
  if not FileExists(UninstallerPath) then
  begin
    OurLog(LogScope, format(
      '"%s" doesn''t point to a file or the file ' +
      'doesn''t exist', [UninstallerPath]));
    exit;
  end;

  // Old "CPack -G NSIS" doesn't write InstallLocation to the
  // Uninstall section. Instead, it writes the path to
  // "Software\(App author)\(App name)". Use this to check if this
  // is actually our old installer. Otherwise, there is no guarantee
  // that this is really an NSIS uninstaller, and we should not try to
  // execute it with NSIS-specific arguments.
  if not RegQueryStringValue(
      RootRegKey, 'Software\@APP_AUTHOR@\@APP_NAME@',
      '', CPackUninstallerDir) then
  begin
    OurLog(LogScope, 'No "Software\@APP_AUTHOR@\@APP_NAME@"');
    exit;
  end;

  UninstallerDir := ExtractFileDir(UninstallerPath);
  if CPackUninstallerDir <> UninstallerDir then
  begin
    OurLog(LogScope, format(
      'String from "Software\@APP_AUTHOR@\@APP_NAME@" (%s) is not ' +
      ' the same as path to uninstaller directory (%s)'
      , [CPackUninstallerDir, UninstallerDir]));
    exit;
  end;

  if not Exec(
    UninstallerPath, '/S _?=' + UninstallerDir, '',
    SW_HIDE, ewWaitUntilTerminated, ExecResultCode) then
  begin
    OurLog(LogScope, format(
      'Can''t execute "%s /S _?=%s": %s (code %d)'
      , [UninstallerPath, UninstallerDir,
      SysErrorMessage(ExecResultCode), ExecResultCode]));
    exit;
  end;

  if not DeleteFile(UninstallerPath) then
  begin
    OurLog(LogScope, format(
      'Can''t delete \"%s\"', [UninstallerPath]));
    exit;
  end;

  if not RemoveDir(UninstallerDir) then
    OurLog(LogScope, format(
      'Can''t delete "%s"; the directory is probably not ' +
      'empty', [UninstallerDir]));

  OurLog(LogScope, format(
    'Uninstalled existing via "%s"', [UninstallerPath]));
end;

const
  UninstallerMutexName = 'iss_@APP_FILE_NAME@_uninstaller_mutex';

// Removing the previous version is not actually necessary with Inno
// Setup. It always appends to the uninstall log, so the uninstaller
// will never leave any files, even if the user has installed several
// versions of the app with different file hierarchies. However, this
// also means that until the user uninstalls the app, unnecessary
// files from previous versions will still waste disk space, so let's
// try to uninstall the existing version automatically.
//
// Alternatively, we could use the [InstallDelete] section, but it's
// rather cumbersome to keep a list of files to be removed for all
// previous versions, and there will be no full cleanup if the user
// rolls back to a previous version.
procedure UninstallExisting();
var
  LogScope: String;
  RootRegKey: Integer;
  UninstallRegPath: String;
  UninstallString: String;
  ExecResultCode: Integer;
  MutexCheckInterval: Integer;
  MutexMaxWaitTime: Integer;
begin
  LogScope := 'UninstallExisting';
  UninstallRegPath :=
    'Software\Microsoft\Windows\CurrentVersion\Uninstall\' +
    '@APP_NAME@_is1';

  if not LocateRootRegKey(
      HKA32, HKA64, UninstallRegPath, RootRegKey) then
    exit;

  if not RegQueryStringValue(
      RootRegKey, UninstallRegPath,
      UninstallStringKey, UninstallString) then
    exit;

  if not Exec(
    '>',
    UninstallString + ' /VERYSILENT /SUPPRESSMSGBOXES /NORESTART',
    '',
    SW_HIDE, ewWaitUntilTerminated, ExecResultCode) then
  begin
    OurLog(LogScope, format(
      'Can''t execute "%s": %s (code %d)'
      , [UninstallString,
      SysErrorMessage(ExecResultCode), ExecResultCode]));
    exit;
  end;

  MutexCheckInterval := 200;
  MutexMaxWaitTime := 10000;

  while MutexMaxWaitTime > 0 do
  begin
    if not CheckForMutexes(UninstallerMutexName) then
    begin
      OurLog(LogScope, 'Uninstaller released the mutex');
      break;
    end;

    Sleep(MutexCheckInterval);
    MutexMaxWaitTime := MutexMaxWaitTime - MutexCheckInterval;
  end;

  OurLog(LogScope, format(
    'Uninstalled existing via "%s"', [UninstallString]));
end;

procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssInstall then
  begin
    UninstallExistingNsis();
    UninstallExisting();
  end;
end;

function InitializeUninstall(): Boolean;
begin
  CreateMutex(UninstallerMutexName);
  Result := True;
end;
